<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>洛谷P1048 采药</title>
      <link href="/2019/08/05/solution-luoguP1048/"/>
      <url>/2019/08/05/solution-luoguP1048/</url>
      
        <content type="html"><![CDATA[<h2 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h2><p>直接枚举加剪枝，最坏复杂度为$O(2^n)$。<br>Code：</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct node{    int jz,sj;}a[105];int ans,m;void dfs(int t,int v,int n){    if(t&gt;m) {        ans=max(ans,n);        return;    }    dfs(t+1,v,n);    if(v-a[t].sj&gt;0) dfs(t+1,v-a[t].sj,n+a[t].jz);    if(v-a[t].sj==0) {        ans=max(ans,n+a[t].jz);        return;    }}int main(){    int time;//由于没开#include&lt;ctime&gt;,因此不会CE。    scanf(&quot;%d%d&quot;,&amp;time,&amp;m);    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;a[i].sj,&amp;a[i].jz);    }    dfs(1,time,0);    printf(&quot;%d\n&quot;,ans);}</code></pre><h2 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h2><h3 id="前置技能：启发式搜索"><a href="#前置技能：启发式搜索" class="headerlink" title="前置技能：启发式搜索"></a>前置技能：<strong>启发式搜索</strong></h3><p>我们写一个估价函数f，可以剪掉所有无效的0枝条（就是剪去大量无用不选枝条。<br>数学上有对此方法的论证，请自行搜索。<br>这样，最慢的测试点才7ms，比刚才的&gt;1000ms快多了！<br>Code：</p><pre><code>#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 105 ;int n,m,ans;struct Node{    int a,b;//a代表时间，b代表价值     double f;}node[N];bool operator&lt; (Node p,Node q) {    return p.f&gt;q.f;}int f(int t,int v){    int tot=0;    for(int i=1;t+i&lt;=n;i++)        if(v&gt;=node[t+i].a){            v-=node[t+i].a;            tot+=node[t+i].b;        }        else             return (int)(tot+v*node[t+i].f);    return tot;}void work(int t,int p,int v){    ans=max(ans,v);    if(t&gt;n) return ;    if(f(t,p)+v&gt;ans) work(t+1,p,v);    if(node[t].a&lt;=p) work(t+1,p-node[t].a,v+node[t].b);}int main(){    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d %d&quot;,&amp;node[i].a,&amp;node[i].b);        node[i].f=1.0*node[i].b/node[i].a;    }    sort(node+1,node+n+1);    work(1,m,0);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷2019春令营 普及组作业题解 Day 1</title>
      <link href="/2019/08/05/luogu-2019-chunlingying-pujizu-zuoyetijie-day1/"/>
      <url>/2019/08/05/luogu-2019-chunlingying-pujizu-zuoyetijie-day1/</url>
      
        <content type="html"><![CDATA[<h2 id="讲师：will7101-内容：模拟与枚举"><a href="#讲师：will7101-内容：模拟与枚举" class="headerlink" title="讲师：will7101   内容：模拟与枚举"></a>讲师：will7101   内容：模拟与枚举</h2><h3 id="作业名单："><a href="#作业名单：" class="headerlink" title="作业名单："></a>作业名单：</h3><ul><li>简单模拟：P2615,P1014</li><li>排序：P1102</li><li>枚举：P1618,P2010</li><li>子集枚举：P1036</li><li>全排列枚举：P1706</li></ul><h2 id="P2615-神奇的幻方"><a href="#P2615-神奇的幻方" class="headerlink" title="P2615 神奇的幻方"></a>P2615 神奇的幻方</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cctype></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> tot<span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">short</span> w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> ch<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isdigit</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>w<span class="token operator">|</span><span class="token operator">=</span>ch<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">;</span>ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>x<span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>x<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>ch<span class="token operator">^</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> w<span class="token operator">?</span><span class="token operator">-</span>x<span class="token operator">:</span>x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">tox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tot<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据口诀，我们先判断1的位置，1是第一行的中间，所以它的x是1</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tot<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//口诀是如果重复的话是往下填，但是我们可以发现，只要填的数的前一个数是n的倍数，那么，它一定会重复，所以我们往下填就可以了，不需要判重的。（比如n=3，现在要填4，那么4的前一个数是3,3是3的倍数，而3的右上角正好有数，所以4可以直接往下填）</span>    x<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个是常规的，往右上角填充。</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> x<span class="token operator">=</span>n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果上出格了，我们要往下填。</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">toy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tot<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//同上，1是第一行的中间，所以它的y是n/2的上取整，我们用(n+1)/2代替。</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tot<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解释同tox过程的第二行。</span>    y<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常规的往右上角填充</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">></span>n<span class="token punctuation">)</span> y<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果右出格了往左边填。</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    n<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tot<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tot<span class="token operator">&lt;=</span>n<span class="token operator">*</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x<span class="token operator">=</span><span class="token function">tox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token function">toy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//通过函数来算出x和y可以节省代码量。</span>        a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>tot<span class="token punctuation">;</span>        tot<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="P1014-Cantor表"><a href="#P1014-Cantor表" class="headerlink" title="P1014 Cantor表"></a>P1014 Cantor表</h2><h3 id="算法1：模拟，按题意一个个枚举"><a href="#算法1：模拟，按题意一个个枚举" class="headerlink" title="算法1：模拟，按题意一个个枚举"></a>算法1：模拟，按题意一个个枚举</h3><p>时间复杂度O(n),基本可以通过本题n≤$10^7$</p><h3 id="算法2：发现Z字形的每条斜线可以快速枚举，即枚举"><a href="#算法2：发现Z字形的每条斜线可以快速枚举，即枚举" class="headerlink" title="算法2：发现Z字形的每条斜线可以快速枚举，即枚举"></a>算法2：发现Z字形的每条斜线可以快速枚举，即枚举</h3><p>1/1 , 1/2 , 3/1 , 1/4 , 5/1 , 1/6……找到要求的第n项所在斜线，再一个个枚举或计算得出答案。<br>时间复杂度O(√n),可以通过n≤$10^{14}$</p><h3 id="算法2-5：枚举第n项在哪一行，计算得出答案。"><a href="#算法2-5：枚举第n项在哪一行，计算得出答案。" class="headerlink" title="算法2.5：枚举第n项在哪一行，计算得出答案。"></a>算法2.5：枚举第n项在哪一行，计算得出答案。</h3><p>比算法2好写,时间复杂度同算法2</p><h3 id="算法3：二分法"><a href="#算法3：二分法" class="headerlink" title="算法3：二分法"></a>算法3：二分法</h3><p>发现第i条斜线（即分子分母之和=i+1的所有项）中包含$i<em>(i-1)/2+1$至$i</em>(i+1)$中的每一项，所以可以二分分子分母之和，再根据分子分母之和的奇偶性直接计算第n项。<br>时间复杂度O(㏒₂n),可以通过n≤$10^{18}$。<br>二分参考代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> l<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>n<span class="token punctuation">,</span>a<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    r<span class="token operator">=</span>n<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        mid<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token operator">*</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">&lt;</span>n<span class="token punctuation">)</span>l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> r<span class="token operator">=</span>mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    a<span class="token operator">=</span>n<span class="token operator">-</span>l<span class="token operator">*</span><span class="token punctuation">(</span>l<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">'/'</span><span class="token operator">&lt;&lt;</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>a<span class="token punctuation">;</span>    <span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>a<span class="token operator">&lt;&lt;</span><span class="token string">'/'</span><span class="token operator">&lt;&lt;</span>a<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="P1102-A-B-数对"><a href="#P1102-A-B-数对" class="headerlink" title="P1102 $A-B$数对"></a>P1102 $A-B$数对</h2><p>这道题用stl库里的map解决很快，只要把A-B=C转换成A-C=B，然后找这N个数里有几个B就解决了。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>map <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> boo<span class="token punctuation">;</span><span class="token keyword">int</span> c<span class="token punctuation">,</span>n<span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">200001</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> s<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        boo<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">=</span>c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> s<span class="token operator">+</span><span class="token operator">=</span>boo<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="P1706-全排列问题"><a href="#P1706-全排列问题" class="headerlink" title="P1706 全排列问题"></a>P1706 全排列问题</h2><p>c++中STL有这样一个函数：</p><pre><code>next_permutation( )</code></pre><p>这是一个求一个排序的下一个排列的函数，可以遍历全排列,要包含头文件#include<algorithm>。</algorithm></p><pre><code>#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int n,r,a[100];//a数组用来储存每一种排列bool used[100];//used数组记录数字是否使用过void print(){//输出函数    for (int i=1;i&lt;=n;++i)         cout&lt;&lt;setw(5)&lt;&lt;a[i];//常宽为5，注意setw( )这个函数    printf(&quot;\n&quot;);//换行}void Search(int t){//搜索函数，t表示搜索到第几位    if (t &gt; n){//已经完成搜索        print();//输出一种答案        return;//退出    }    for (int i=1;i&lt;=n;++i){//这里需要注意，题目是排列而不是组合，因此从1枚举到n        if (!used[i]){//当前枚举数字没有使用过            a[t] = i;//用a数组记录下来            used[i] = true;//已使用过            Search(t+1);//继续搜索            a[t] = 0;//回溯，这里可以不要，但对于这种基础题，要培养写回溯的习惯            used[i] = false;//回溯        }    }}int main(){    cin&gt;&gt;n;//读入    Search(1);//搜索    return 0;}</code></pre><h2 id="P1036-选数"><a href="#P1036-选数" class="headerlink" title="P1036 选数"></a>P1036 选数</h2><p>首先，我们写一个dfs函数，赋予三个变量，分别为step, sum, cnt。 我们用step 来记录当前选的是第几个数，sum 是这个数，cnt是已选的可行的数。同时，我们可以用一个a数组来记录我们所选的数。最后进行素数判断，用sqrt的朴素版即可。</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int a[10001];  //记录所选的数int n,k,sum,total;  //total为总方案数inline void print()  //打印函数{    printf(&quot;%d&quot;,total);}inline bool prime(int x)  //素数判断{    for(register int i=2;i&lt;=sqrt(x);i++)        if(x%i==0) return false;        else return true;}inline void dfs(int step,int sum,int cnt){    if(step==n+1||cnt==k)  //如果已经进行到了n+1次，或者是已经选了k个数    {        if(prime(sum) &amp;&amp; cnt==k)  //如果sum为一个素数且已经选了k个数            total++;  //总方案书+1        return;  //返回    }    dfs(step+1,sum+a[step],cnt+1);  //继续搜索，选择下一个数    dfs(step+1,sum,cnt);  //继续枚举不选择下一个数的情况    return;}int main(){    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    for(register int i=1;i&lt;=n;i++)        scanf(&quot;%d&quot;,&amp;a[i]);    dfs(1,0,0);  //从第个数开始搜    print();  //最后打印结果    return 0;}</code></pre><h2 id="P1618-三连击（升级版）"><a href="#P1618-三连击（升级版）" class="headerlink" title="P1618 三连击（升级版）"></a>P1618 三连击（升级版）</h2><p>仍然使用STL中的next_permutation函数。</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int a[10]={0,1,2,3,4,5,6,7,8,9};int main(){    int A,B,C,h=0;    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;    int t=A*B*C;    A=t/A;    B=t/B;    C=t/C;    do{        if((100*a[1]+10*a[2]+a[3])*A==(100*a[4]+10*a[5]+a[6])*B&amp;&amp;(100*a[1]+10*a[2]+a[3])*A==(100*a[7]+10*a[8]+a[9])*C)//如果符合比例；        {            cout&lt;&lt;a[1]&lt;&lt;a[2]&lt;&lt;a[3]&lt;&lt;&quot; &quot;&lt;&lt;a[4]&lt;&lt;a[5]&lt;&lt;a[6]&lt;&lt;&quot; &quot;&lt;&lt;a[7]&lt;&lt;a[8]&lt;&lt;a[9]&lt;&lt;endl;//输出            h++;        }    }while(next_permutation(a+1,a+10));//STL中的下一个排列函数；    if(h==0) cout&lt;&lt;&quot;No!!!&quot;;//没有解输出NO；    return 0;}</code></pre><h2 id="P2010-回文日期"><a href="#P2010-回文日期" class="headerlink" title="P2010 回文日期"></a>P2010 回文日期</h2><p>我们可以一次性把所有的回文全部构造出来放到一个列表当中，然后根据输入的data1和data2日期来查表求解</p><p>根据日期1～31日 和月份1～12 一共有31*12=372个组合；考虑到4月、6月、9月和11月这4个月没有31日；2月没有30和31两天. （至于2月29日，按照回文对照的年是9220年是闰年有效）有效的回文数是372-4-2=366个。</p><p>全部回文的构造方法： 把需要去除的6个年份建立一个表badYear[6]，并且按照从小到大大顺序排列好。 把月份和日期按照回文方式反转后构成两个表month[31] 和day[12]，并排序； 对这两个表建立双重循环，就可以生成372个从小到大有序排列的年份，在生成的过程当中剔除badYear数组当中已有的6个年份，结果保留在year[366]这个数组当中；再根据这个数组来成声回文数组：cycleText[366]</p><p>因为他们是有序排列的，data1和data2的定位和查找就可以各种优化（比如二分查找等），但是表格只有366个长度这里简单的直接处理就好。</p><pre><code>#include &lt;iostream&gt;using namespace std;int main ( ) {    int month[12] = { 01, 10, 11, 20,             21, 30, 40, 50,             60, 70, 80, 90, };    int day[31] = { 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 30, 31, 32, 40, 41, 42, 50, 51, 52, 60, 61, 62, 70, 71, 72, 80, 81, 82, 90, 91, 92, };    int badYear[6] = { 320, 1311, 1320, 1340, 1360, 1390, };    // 不存在的年份有6个； 不能写0320 否则就是当做8进制数据来处理了    int year[366];    string cycleText[366];    int count=0;    int t =0;    for ( int i=0; i&lt;31; i++) {        for ( int j=0; j&lt;12; j++) {            int y = day[i]*100+month[j];            // badYear也是排序过的，所以每次只要和最小的比较就好了            if ( badYear[t]==y ) {                // 找到一个badYear，下次比较下一个badYear                t++;                continue;            }  else {                year[count++]=y;            };        };    };    for ( int i=0; i&lt;366; i++) {        char temp[9]; temp[8]=0;        int t=year[i];        temp[3] = temp[4] = (t%10) + &#39;0&#39;; t /= 10;        temp[2] = temp[5] = (t%10) + &#39;0&#39;; t /= 10;        temp[1] = temp[6] = (t%10) + &#39;0&#39;; t /= 10;        temp[0] = temp[7] = t + &#39;0&#39;;        cycleText[i] = temp;    };    string data1, data2;    cin &gt;&gt; data1 &gt;&gt; data2;     if ( data1 &gt; data2 ) swap(data1, data2);      // 确保data1d&lt;=data2;    count = 0;    for ( int i=0; i&lt;366; i++ ) {        if ( cycleText[i] &lt; data1 ) continue;        if ( cycleText[i] &gt; data2 ) break;        count ++;    };    cout &lt;&lt; count;    return 0;}</code></pre><h3 id="制作：yuntianming-审稿：zxcpoi"><a href="#制作：yuntianming-审稿：zxcpoi" class="headerlink" title="制作：yuntianming 审稿：zxcpoi"></a>制作：yuntianming 审稿：zxcpoi</h3>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美工组自招简章</title>
      <link href="/2019/08/01/Moj_Art_Group/"/>
      <url>/2019/08/01/Moj_Art_Group/</url>
      
        <content type="html"><![CDATA[<h2 id="美工组自招简章"><a href="#美工组自招简章" class="headerlink" title="美工组自招简章"></a>美工组自招简章</h2><h3 id="1-加入要求"><a href="#1-加入要求" class="headerlink" title="1. 加入要求"></a><strong>1.</strong> <strong>加入要求</strong></h3><pre><code>1.1 测试要求    组长/副组长出两道题目，1小时完成1道即可。完成后即可开始1~2周的实习。1.2 测试范围    包括Photoshop和flash，只需熟练运用即可。1.3 特殊贡献    被 @yemaster 提名者或特殊贡献者，可跳过测试，直接成为实习组员。1.4 特殊测试（选做）    参加本组的特殊测试和普通测试，即可跳过实习期。    测试的项目为Photoshop和flash基础知识。</code></pre><h3 id="2-工作范围与人选问题"><a href="#2-工作范围与人选问题" class="headerlink" title="2. 工作范围与人选问题"></a><strong>2.</strong> <strong>工作范围与人选问题</strong></h3><pre><code>原则上来说，任务较轻的由组员完成，复杂的由组长/副组长完成或美工组集体完成。</code></pre><h3 id="3-实习问题"><a href="#3-实习问题" class="headerlink" title="3. 实习问题"></a><strong>3.</strong> <strong>实习问题</strong></h3><pre><code>3.1 实习工作    实习期间，所有与美工组有关的工作，除特殊工作外，实习成员均需提交一份。若实习期间贡献突出者，可直接成为正式组员，无需投票。3.2 不合格者处理方法    3.2.1不合格者具体定义        不完成任务、质量过差者    3.2.2 不合格处理规范        1.第一次由组长/组员进行提示。        2.第二次延长一周的实习期。        3.第三次延长至一个月。        4.第四次取消实习资格3.3 正式组员投票决定    由实习组员转为正式组员，需经过正式组员的不记名投票。票数超过1/2即可成为正式组员。</code></pre><h3 id="4-正式组员规定"><a href="#4-正式组员规定" class="headerlink" title="4. 正式组员规定"></a><strong>4.</strong> <strong>正式组员规定</strong></h3><pre><code>在遇到工作时，除遇到其他事项外，都应当在24小时内进行处理，最迟在第三天进行反馈。</code></pre><h3 id="5-组长和副组长"><a href="#5-组长和副组长" class="headerlink" title="5. 组长和副组长"></a><strong>5.</strong> <strong>组长和副组长</strong></h3><pre><code>在成为正式组员以后，允许向 @yuntianming 申请副组长职务，随后进行组员投票，有2/3的正式组员同意即可。副组长一共2名，报满为止。</code></pre><h3 id="6-报名事项"><a href="#6-报名事项" class="headerlink" title="6. 报名事项"></a><strong>6.</strong> <strong>报名事项</strong></h3><pre><code>请填写 附件2 中的报名表，发送给yuntianming。</code></pre><p><strong>美工组</strong></p><p><strong>2017/7/27</strong></p><p>附件1 <strong>美工组名单</strong></p><pre><code>组长：yuntianming副组长：duboyan（实习）（兼职）组员：（暂缺）</code></pre><p>附件2 <strong>报名表</strong></p><table><thead><tr><th><strong>报名人</strong></th><th><strong>测试时间</strong></th><th><strong>QQ</strong>昵称</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>我们将在该时间往你的<strong>QQ</strong>账号/<strong>MasterOJ</strong>官方<strong>QQ</strong>群中发送题目，请注意查收。</p>]]></content>
      
      
      <categories>
          
          <category> 美工组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Moj </tag>
            
            <tag> 美工组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
